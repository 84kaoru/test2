<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>VRæ±å°‹åŠã‚³ãƒ¼ã‚¹ã‚¿ãƒ¼ - VR-Tojinbo-Coaster</title>
<style>
body {
	margin: 0;
}
</style>
</head>
<body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from "three";
import { Curve, makeCurve, addCoaster } from "./TojinboCoaster.js";
import { VRButton } from "three/addons/webxr/VRButton.js";
import { WindNode } from "./WindNode.js";
import { setVBMode } from "./setVBMode.js";

const vbmode = location.hash == "#vbmode";

// wind audio
let context = null;
let audionode = null;

const stop = async () => {
  if (!context) return;
  await context.close();
  context = null;
	audionode = null;
};

const start = async () => {
  if (context) await stop();
  const sampleRate = 48000; // mac default
  context = new AudioContext({ sampleRate });

  const node = await WindNode.create(context);
  const fn = "./wind.wav";
  node.setWaveFile(fn);
  node.setOverwrap(0.058);
  node.connect(context.destination);
	audionode = node;
	
  //node.setVolume(range.value);
  //node.setPitch(range2.value);
};

//
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType("local");
document.body.appendChild(renderer.domElement);
const btn = VRButton.createButton(renderer);
btn.addEventListener("click", () => {
	start();
});
document.body.appendChild(btn);
window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
});

const scene = new THREE.Scene();

//const curve = makeCurve();
const curve = new Curve();
//await addCoaster(scene, curve, true);
await addCoaster(scene, curve);

if (vbmode) {
	setVBMode(scene);
}

const train = new THREE.Object3D();
scene.add(train);
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
// ã‚«ãƒ¡ãƒ©ã‚’binormalã®æ­£ã®æ–¹å‘ã«é…ç½®
// é€šå¸¸åŒºé–“ï¼šbinormalã¯ä¸‹ãªã®ã§ã€ã‚«ãƒ¡ãƒ©ã¯ä¸‹ï¼ˆ+0.6ï¼‰= ãƒ¬ãƒ¼ãƒ«ã®ä¸‹ã‹ã‚‰ä¸Šã‚’è¦‹ã‚‹
// ãƒ«ãƒ¼ãƒ—åŒºé–“ï¼šbinormalã¯å†…å‘ããªã®ã§ã€ã‚«ãƒ¡ãƒ©ã¯å†…å´ï¼ˆ+0.6ï¼‰= å†…å´ã‹ã‚‰å¤–ã‚’è¦‹ã‚‹
camera.position.set(0, 0.6, 0);
train.add(camera);

const position = new THREE.Vector3();
const tangent = new THREE.Vector3();
const lookAt = new THREE.Vector3();

// çŠ¶æ…‹ç®¡ç†ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã«1ã¤ã®å¤‰æ•°ã§ç®¡ç†ï¼‰
const STATE = {
  STOPPED: 'stopped',   // åœæ­¢ä¸­ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ï¼‰
  RUNNING: 'running',   // èµ°è¡Œä¸­
};
let coasterState = STATE.STOPPED;

let velocity = 0;
let progress = 0;
let prevProgress = 0;

// ä¸Šã‚’è¦‹ã¤ã‚ã‚‹æ™‚é–“è¨ˆæ¸¬ç”¨
let lookingUpTime = 0;
const LOOK_UP_THRESHOLD = 3000; // 3ç§’ï¼ˆãƒŸãƒªç§’ï¼‰

// ç™ºè»Šæ™‚åˆ»
let startTime = 0;

let prevTime = performance.now();

// ãƒã‚¦ã‚¹æ“ä½œç”¨ã®å¤‰æ•°
let mouseYaw = 0; // å·¦å³ã®å›è»¢
let mousePitch = 0; // ä¸Šä¸‹ã®å›è»¢
let isPointerLocked = false;

// ãƒã‚¦ã‚¹ã®ç§»å‹•ã‚’è¿½è·¡
renderer.domElement.addEventListener('mousemove', (event) => {
	if (isPointerLocked) {
		const sensitivity = 0.002;
		mouseYaw -= event.movementX * sensitivity;
		mousePitch -= event.movementY * sensitivity;
		
		// ä¸Šä¸‹ã®å›è»¢ã‚’åˆ¶é™ï¼ˆ-90åº¦ã‹ã‚‰+90åº¦ï¼‰
		mousePitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mousePitch));
	}
});

// ã‚¯ãƒªãƒƒã‚¯ã§ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ã¨ç™ºè»Š/åœæ­¢
renderer.domElement.addEventListener('click', () => {
	if (!isPointerLocked) {
		renderer.domElement.requestPointerLock();
	}
	if (coasterState === STATE.STOPPED) {
		start();
		coasterState = STATE.RUNNING;
		velocity = 0.00045; // åˆé€Ÿåº¦ï¼ˆ3/4ï¼‰
		startTime = performance.now(); // ç™ºè»Šæ™‚åˆ»ã‚’è¨˜éŒ²
		console.log("ç™ºè»Šï¼");
	} else if (coasterState === STATE.RUNNING) {
		coasterState = STATE.STOPPED;
		velocity = 0;
		startTime = 0;
		console.log("åœæ­¢");
	}
});

// ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’è¿½è·¡
document.addEventListener('pointerlockchange', () => {
	isPointerLocked = document.pointerLockElement === renderer.domElement;
	if (!isPointerLocked) {
		console.log("ãƒã‚¦ã‚¹æ“ä½œçµ‚äº†ï¼ˆESCã‚­ãƒ¼ã§è§£é™¤ï¼‰");
	} else {
		console.log("ãƒã‚¦ã‚¹ã§è¦–ç‚¹ã‚’æ“ä½œã§ãã¾ã™ / ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§åœæ­¢/ç™ºè»Š");
	}
});

const handles = await addCoaster(scene, curve);
let isNight = false;

// ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ç™ºè»Š/åœæ­¢ã‚’åˆ‡ã‚Šæ›¿ãˆ
document.addEventListener('keydown', (event) => {
	if (event.code === 'Space') {
		event.preventDefault(); // ãƒšãƒ¼ã‚¸ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
		if (coasterState === STATE.STOPPED) {
			start();
			coasterState = STATE.RUNNING;
			velocity = 0.00045; // åˆé€Ÿåº¦ï¼ˆ3/4ï¼‰
			startTime = performance.now(); // ç™ºè»Šæ™‚åˆ»ã‚’è¨˜éŒ²
			console.log("ç™ºè»Šï¼");
		} else if (coasterState === STATE.RUNNING) {
			coasterState = STATE.STOPPED;
			velocity = 0;
			startTime = 0;
			console.log("åœæ­¢");
		}
	}

	// è¿½åŠ ï¼šNã‚­ãƒ¼ã§ç©ºã®æ˜æš—ãƒˆã‚°ãƒ«
  	 if (event.code === 'KeyN') {
    isNight = !isNight;
    // ç”»åƒã ã‘æš—ãã—ãŸã„ â†’ handles.setSkyBrightness(isNight ? 0.015 : 1.0);
    // å…‰ã‚‚å¼±ã‚ãŸã„ â†’ handles.setNight(isNight);
    handles.setNight(isNight);
  	}
});

const NIGHT_HOLD_MS    = 1500;  // ä½•msè¦‹ç¶šã‘ãŸã‚‰åˆ‡æ›¿ï¼ˆ1.5ç§’ï¼‰
const Y_DOWN_THRESHOLD = -0.65; // ã€Œä¸‹å‘ãã€åˆ¤å®šï¼ˆç´„40åº¦ä»¥ä¸Šï¼‰
const TOGGLE_COOLDOWN  = 1500;  // é€£ç¶šèª¤ä½œå‹•ã‚’é˜²ãã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³(ms)

let nightMode = false;     // ç¾åœ¨ã®å¤œãƒ¢ãƒ¼ãƒ‰çŠ¶æ…‹
let lookDownHold = 0;      // ä¸‹å‘ãç´¯ç©æ™‚é–“
let lastNightToggleAt = 0; // ç›´è¿‘ãƒˆã‚°ãƒ«æ™‚åˆ»

function updateNightModeVR(delta /* ms */, time /* ms */) {
  if (!renderer.xr.isPresenting) {
    lookDownHold = 0;
    return;
  }

  // èµ°è¡Œä¸­ã¯åˆ‡æ›¿ãˆãªã„ãªã‚‰ã“ã‚Œã§OK
  if (coasterState === STATE.RUNNING) {
    lookDownHold = 0;
    return;
  }

  // VRã‚«ãƒ¡ãƒ©ã®å‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«
  const vrCam = renderer.xr.getCamera(camera);
  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(vrCam.quaternion);

  const canToggle = (time - lastNightToggleAt) > TOGGLE_COOLDOWN;

  if (forward.y < Y_DOWN_THRESHOLD) {
    // ä¸‹å‘ã
    lookDownHold += delta;

    if (canToggle && lookDownHold >= NIGHT_HOLD_MS) {
      nightMode = !nightMode;
      lastNightToggleAt = time;
      lookDownHold = 0;

      // â† addCoaster ã®æˆ»ã‚Šå€¤
      handles.setNight(nightMode);
      console.log(nightMode ? "ğŸŒ™ Night mode ON" : "â˜€ï¸ Night mode OFF");
    }
  } else {
    // ã—ãã„å€¤ã‹ã‚‰å¤–ã‚ŒãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
    lookDownHold = 0;
  }
}

renderer.setAnimationLoop(() => {
	const time = performance.now();
	const delta = time - prevTime;

	// é€Ÿåº¦ã®ç¯„å›²
	const vmin = 0.00018; // æœ€å°é€Ÿåº¦ï¼ˆ3/4ï¼‰
	const vmax = 0.0009; // æœ€å¤§é€Ÿåº¦ï¼ˆ3/4ï¼‰

	// 1å‘¨ã—ãŸã“ã¨ã‚’æ¤œå‡º
	const hasLooped = prevProgress > 0.8 && progress < 0.2;
	
	// 1å‘¨ã—ãŸã‚‰è‡ªå‹•åœæ­¢ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã«æˆ»ã‚‹
	if (hasLooped && coasterState === STATE.RUNNING) {
		coasterState = STATE.STOPPED;
		velocity = 0;
		progress = 0; // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã«æˆ»ã‚‹
		startTime = 0; // ãƒªã‚»ãƒƒãƒˆ
		
		// 1å‘¨å®Œäº†æ™‚ã¯çœ‹æ¿ã‚’ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã«æˆ»ã™
		if (scene.userData.signControl && scene.userData.signControl.isGoal) {
			scene.userData.signControl.updateTexture(scene.userData.signControl.texture, 'ã‚¹ã‚¿ãƒ¼ãƒˆ');
			scene.userData.signControl.material.emissiveMap = scene.userData.signControl.texture;
			scene.userData.signControl.isGoal = false;
			console.log("çœ‹æ¿ã‚’ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã«å¤‰æ›´ã—ã¾ã—ãŸ");
		}
		
		console.log("1å‘¨å®Œäº†ï¼ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã«æˆ»ã‚Šã¾ã—ãŸã€‚3ç§’é–“ä¸Šã‚’è¦‹ã¦å†ã‚¹ã‚¿ãƒ¼ãƒˆã§ãã¾ã™");
	}

	prevProgress = progress;
	
	// ç§»å‹•ä¸­ã®ã¿progressã‚’æ›´æ–°
	if (coasterState === STATE.RUNNING) {
		progress += velocity;
		progress = progress % 1;
	}

	position.copy(curve.getPointAt(progress));
	// trainã®ä½ç½®ã¯ãƒ¬ãƒ¼ãƒ«ã®ä½ç½®ãã®ã¾ã¾ï¼ˆã‚«ãƒ¡ãƒ©ã¯trainã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ç³»ã§-0.6ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
	train.position.copy(position);
	tangent.copy(curve.getTangentAt(progress));

	// ç§»å‹•ä¸­ã®ã¿é€Ÿåº¦ã‚’è¨ˆç®—
	if (coasterState === STATE.RUNNING) {
		velocity -= tangent.y * 0.00000045 * delta; // åŠ é€Ÿåº¦ä¿‚æ•°ï¼ˆ3/4ï¼‰
		velocity = Math.max(vmin, Math.min(vmax, velocity));
	}

	// VRãƒ¢ãƒ¼ãƒ‰ã§ä¸Šã‚’è¦‹ã¤ã‚ã‚‹æ™‚é–“ã‚’è¨ˆæ¸¬ï¼ˆåœæ­¢ä¸­ã®ã¿ï¼‰
	if (renderer.xr.isPresenting && coasterState === STATE.STOPPED) {
		// VRã‚«ãƒ¡ãƒ©ã®å‘ãã‚’å–å¾—
		const vrCamera = renderer.xr.getCamera(camera);
		const cameraDirection = new THREE.Vector3(0, 0, -1);
		cameraDirection.applyQuaternion(vrCamera.quaternion);
		
		// ä¸Šã‚’è¦‹ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆYæˆåˆ†ãŒ0.7ä»¥ä¸Šãªã‚‰ä¸Šå‘ãã€ç´„45åº¦ä»¥ä¸Šï¼‰
		if (cameraDirection.y > 0.7) {
			lookingUpTime += delta;
			
			// 3ç§’é–“ä¸Šã‚’è¦‹ç¶šã‘ãŸã‚‰ç™ºè»Š
			if (lookingUpTime >= LOOK_UP_THRESHOLD) {
				start();
				coasterState = STATE.RUNNING;
				velocity = 0.00045; // åˆé€Ÿåº¦ï¼ˆ3/4ï¼‰
				startTime = time; // ç™ºè»Šæ™‚åˆ»ã‚’è¨˜éŒ²
				lookingUpTime = 0;
				console.log("ä¸Šã‚’è¦‹ã¤ã‚ã¦ç™ºè»Šã—ã¾ã—ãŸï¼");
			} else {
				// é€²è¡ŒçŠ¶æ³ã‚’è¡¨ç¤ºï¼ˆ0.1ç§’ã”ã¨ï¼‰
				if (Math.floor(lookingUpTime / 100) !== Math.floor((lookingUpTime - delta) / 100)) {
					console.log(`ä¸Šã‚’è¦‹ã¤ã‚ã¦ã„ã¾ã™... ${(lookingUpTime / 1000).toFixed(1)}ç§’ / 3ç§’`);
				}
			}
		} else {
			// ä¸Šã‚’è¦‹ã‚‹ã®ã‚’ã‚„ã‚ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
			if (lookingUpTime > 0) {
				console.log("ä¸Šã‚’è¦‹ã‚‹ã®ã‚’ã‚„ã‚ã¾ã—ãŸ");
			}
			lookingUpTime = 0;
		}
	} else {
		// VRãƒ¢ãƒ¼ãƒ‰ã§ãªã„ã€ã¾ãŸã¯èµ°è¡Œä¸­ã®å ´åˆã¯æ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆ
		lookingUpTime = 0;
	}

	updateNightModeVR(delta, time);


	// ã‚«ãƒ¡ãƒ©ã‚’é€²è¡Œæ–¹å‘ã«å‘ã‘ã‚‹ï¼ˆVRãƒ¢ãƒ¼ãƒ‰ã§ãªã„å ´åˆï¼‰
	if (!renderer.xr.isPresenting) {
		// ãƒ«ãƒ¼ãƒ—åŒºé–“ã§ã®upãƒ™ã‚¯ãƒˆãƒ«ã®è¨ˆç®—
		let upVector = new THREE.Vector3(0, 1, 0);
		
		if (progress >= curve.loopStart && progress <= curve.loopEnd) {
			// ãƒ«ãƒ¼ãƒ—å†…ã§ã®é€²è¡Œåº¦
			const loopProgress = (progress - curve.loopStart) / (curve.loopEnd - curve.loopStart);
			const loopAngle = -Math.PI / 2 + loopProgress * Math.PI * 2;
			
			// ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ç‚¹ã§ã®é€šå¸¸ã‚³ãƒ¼ã‚¹ã®ä½ç½®
			const tScaledStart = curve.loopStart * Math.PI;
			const dx = Math.cos(tScaledStart * 4) * 4;
			const dy = Math.cos(tScaledStart * 10) * 10;
			const dz = -Math.sin(tScaledStart * 2) * 2;
			
			const dirLength = Math.sqrt(dx * dx + dy * dy + dz * dz);
			const forwardX = dx / dirLength;
			const forwardY = dy / dirLength;
			const forwardZ = dz / dirLength;
			
			const worldUpX = 0, worldUpY = 1, worldUpZ = 0;
			const rightX = forwardY * worldUpZ - forwardZ * worldUpY;
			const rightY = forwardZ * worldUpX - forwardX * worldUpZ;
			const rightZ = forwardX * worldUpY - forwardY * worldUpX;
			
			const rightLength = Math.sqrt(rightX * rightX + rightY * rightY + rightZ * rightZ);
			const normRightX = rightX / rightLength;
			const normRightY = rightY / rightLength;
			const normRightZ = rightZ / rightLength;
			
			const localUpX = normRightY * forwardZ - normRightZ * forwardY;
			const localUpY = normRightZ * forwardX - normRightX * forwardZ;
			const localUpZ = normRightX * forwardY - normRightY * forwardX;
			
			// ãƒ«ãƒ¼ãƒ—ã®ä¸­å¿ƒã‹ã‚‰å¤–å´ã¸ã®æ–¹å‘ã‚’è¨ˆç®—
			const radialX = forwardX * Math.cos(loopAngle) + localUpX * Math.sin(loopAngle);
			const radialY = forwardY * Math.cos(loopAngle) + localUpY * Math.sin(loopAngle);
			const radialZ = forwardZ * Math.cos(loopAngle) + localUpZ * Math.sin(loopAngle);
			
			// å†…å‘ã = upãƒ™ã‚¯ãƒˆãƒ«ï¼ˆbinormalã¨ä¸€è‡´ï¼‰
			upVector.set(-radialX, -radialY, -radialZ).normalize();
		}
		
		// æ­£ã—ã„åº§æ¨™ç³»ã‚’æ§‹ç¯‰
		// forward = tangent (é€²è¡Œæ–¹å‘ = Zè»¸ã®é€†)
		// up = upVector (é ­ã®æ–¹å‘ = Yè»¸)
		// right = tangent Ã— upVector (å³æ–¹å‘ = Xè»¸)
		const forward = tangent.clone().normalize();
		const right = new THREE.Vector3().crossVectors(forward, upVector).normalize();
		const up = new THREE.Vector3().crossVectors(right, forward).normalize();
		
		// å›è»¢è¡Œåˆ—ã‚’ä½œæˆï¼ˆThree.jsã®ã‚«ãƒ¡ãƒ©ã¯-Zæ–¹å‘ã‚’è¦‹ã‚‹ï¼‰
		const matrix = new THREE.Matrix4();
		matrix.makeBasis(right, up, forward.clone().negate());
		train.quaternion.setFromRotationMatrix(matrix);
		
		// ãƒã‚¦ã‚¹æ“ä½œã«ã‚ˆã‚‹è¿½åŠ ã®å›è»¢ã‚’ã‚«ãƒ¡ãƒ©ã«é©ç”¨
		camera.rotation.set(mousePitch, mouseYaw, 0);
	}

	// çœ‹æ¿ã®æ–‡å­—åˆ‡ã‚Šæ›¿ãˆï¼ˆç™ºè»Šã‹ã‚‰3ç§’çµŒéã§ã€Œã‚´ãƒ¼ãƒ«ã€ï¼‰
	if (scene.userData.signControl) {
		const signControl = scene.userData.signControl;
		
		// ç™ºè»Šã‹ã‚‰3ç§’çµŒéã—ãŸã‚‰ã€Œã‚´ãƒ¼ãƒ«ã€ã«åˆ‡ã‚Šæ›¿ãˆ
		if (coasterState === STATE.RUNNING && startTime > 0 && (time - startTime) >= 3000 && !signControl.isGoal) {
			signControl.updateTexture(signControl.texture, 'ã‚´ãƒ¼ãƒ«');
			signControl.material.emissiveMap = signControl.texture;
			signControl.isGoal = true;
			console.log("çœ‹æ¿ã‚’ã€Œã‚´ãƒ¼ãƒ«ã€ã«å¤‰æ›´ã—ã¾ã—ãŸ");
		}
		// ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã¸ã®åˆ‡ã‚Šæ›¿ãˆã¯1å‘¨å®Œäº†æ™‚ã®ã¿ï¼ˆä¸Šè¨˜ã®1å‘¨æ¤œå‡ºå‡¦ç†ã§è¡Œã†ï¼‰
	}

	// å¸ƒã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
	if (scene.userData.animatedMeshes) {
		scene.userData.animatedMeshes.forEach(mesh => {
			if (mesh.userData.isCloth) {
				mesh.userData.time += delta * 0.001;
				const t = mesh.userData.time;
				
				const geometry = mesh.geometry;
				const positions = geometry.attributes.position;
				const originalPositions = geometry.userData.originalPositions;
				
				// å„é ‚ç‚¹ã‚’æ³¢æ‰“ãŸã›ã‚‹ï¼ˆä¸‹åŠåˆ†ã®ã¿ï¼‰
				for (let i = 0; i < positions.count; i++) {
					const i3 = i * 3;
					const x = originalPositions[i3];
					const y = originalPositions[i3 + 1];
					
					// ä¸ŠåŠåˆ†ï¼ˆy > 0ï¼‰ã¯å›ºå®šã€ä¸‹åŠåˆ†ï¼ˆy <= 0ï¼‰ã®ã¿å‹•ã‹ã™
					if (y <= 0) {
						// yåº§æ¨™ã«å¿œã˜ã¦å‹•ãã®å¼·ã•ã‚’å¤‰ãˆã‚‹ï¼ˆä¸Šéƒ¨:0 â†’ ä¸‹éƒ¨:1ï¼‰
						const heightFactor = Math.abs(y / 5); // 0ã‹ã‚‰1ã®ç¯„å›²
						
						// é¢¨ã«ã‚ˆã‚‹æ³¢ã®åŠ¹æœ
						const wave1 = Math.sin(x * 0.3 + t * 2) * 0.4;
						const wave2 = Math.cos(y * 0.4 + t * 1.5) * 0.3;
						const wave3 = Math.sin(x * 0.2 + y * 0.3 + t * 2.5) * 0.5;
						
						// Zè»¸æ–¹å‘ã«æ³¢æ‰“ãŸã›ã‚‹ï¼ˆé«˜ã•ã«ã‚ˆã£ã¦å¼·åº¦ã‚’èª¿æ•´ï¼‰
						positions.setZ(i, (wave1 + wave2 + wave3) * heightFactor);
					} else {
						// ä¸ŠåŠåˆ†ã¯å…ƒã®ä½ç½®ã«å›ºå®šï¼ˆãƒã‚§ãƒ¼ãƒ³ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ï¼‰
						positions.setZ(i, originalPositions[i3 + 2]);
					}
				}
				
				positions.needsUpdate = true;
				geometry.computeVertexNormals();
			}
		});
	}

	renderer.render(scene, camera);
	prevTime = time;

	if (audionode) {
		const vp = (velocity - vmin) / (vmax - vmin);
		const pitch = 1 + vp;
		const vol = 0.3 + vp * .3;
		audionode.setPitchVolume(pitch, vol);
	}
});
</script>

</body>
</html>
